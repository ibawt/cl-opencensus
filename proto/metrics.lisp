
;;;;    opencensus/proto/metrics/v1/metrics.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:opencensus.proto.metrics.v1)
    (make-package '#:opencensus.proto.metrics.v1 :use nil)))
(in-package #:opencensus.proto.metrics.v1)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:deftype metric-descriptor-type () '(cl:member 0 1 2 3 4 5 6 7))
(cl:export 'metric-descriptor-type)

(cl:defconstant +metric-descriptor-type-unspecified+ 0)
(cl:export '+metric-descriptor-type-unspecified+)
(cl:defconstant +metric-descriptor-type-gauge-int64+ 1)
(cl:export '+metric-descriptor-type-gauge-int64+)
(cl:defconstant +metric-descriptor-type-gauge-double+ 2)
(cl:export '+metric-descriptor-type-gauge-double+)
(cl:defconstant +metric-descriptor-type-gauge-distribution+ 3)
(cl:export '+metric-descriptor-type-gauge-distribution+)
(cl:defconstant +metric-descriptor-type-cumulative-int64+ 4)
(cl:export '+metric-descriptor-type-cumulative-int64+)
(cl:defconstant +metric-descriptor-type-cumulative-double+ 5)
(cl:export '+metric-descriptor-type-cumulative-double+)
(cl:defconstant +metric-descriptor-type-cumulative-distribution+ 6)
(cl:export '+metric-descriptor-type-cumulative-distribution+)
(cl:defconstant +metric-descriptor-type-summary+ 7)
(cl:export '+metric-descriptor-type-summary+)

(cl:defconstant +minimum-metric-descriptor-type+ +metric-descriptor-type-unspecified+)
(cl:export '+minimum-metric-descriptor-type+)
(cl:defconstant +maximum-metric-descriptor-type+ +metric-descriptor-type-summary+)
(cl:export '+maximum-metric-descriptor-type+)

(cl:defclass metric (pb:protocol-buffer)
  (
  (metric-descriptor
   :writer (cl:setf metric-descriptor)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.metrics.v1::metric-descriptor))
  (timeseries
   :accessor timeseries
   :initform (cl:make-array
              0
              :element-type 'opencensus.proto.metrics.v1::time-series
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector opencensus.proto.metrics.v1::time-series))
  (resource
   :writer (cl:setf resource)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.resource.v1::resource))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'metric)

(cl:export 'metric-descriptor)

(cl:unless (cl:fboundp 'metric-descriptor)
  (cl:defgeneric metric-descriptor (proto)))
(cl:defmethod metric-descriptor ((self metric))
  (cl:let ((result (cl:slot-value self 'metric-descriptor)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.metrics.v1::metric-descriptor))
      (cl:setf (cl:slot-value self 'metric-descriptor) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf metric-descriptor) :after (x (self metric))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-metric-descriptor)
  (cl:defgeneric has-metric-descriptor (proto)))
(cl:defmethod has-metric-descriptor ((self metric))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-metric-descriptor)

(cl:unless (cl:fboundp 'clear-metric-descriptor)
  (cl:defgeneric clear-metric-descriptor (proto)))
(cl:defmethod clear-metric-descriptor ((self metric))
  (cl:setf (cl:slot-value self 'metric-descriptor) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-metric-descriptor)

(cl:export 'timeseries)

(cl:unless (cl:fboundp 'clear-timeseries)
  (cl:defgeneric clear-timeseries (proto)))
(cl:defmethod clear-timeseries ((self metric))
  (cl:setf (cl:slot-value self 'timeseries)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::time-series
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-timeseries)

(cl:export 'resource)

(cl:unless (cl:fboundp 'resource)
  (cl:defgeneric resource (proto)))
(cl:defmethod resource ((self metric))
  (cl:let ((result (cl:slot-value self 'resource)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.resource.v1::resource))
      (cl:setf (cl:slot-value self 'resource) result))
      (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf resource) :after (x (self metric))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-resource)
  (cl:defgeneric has-resource (proto)))
(cl:defmethod has-resource ((self metric))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-resource)

(cl:unless (cl:fboundp 'clear-resource)
  (cl:defgeneric clear-resource (proto)))
(cl:defmethod clear-resource ((self metric))
  (cl:setf (cl:slot-value self 'resource) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-resource)


(cl:defmethod cl:print-object ((self metric) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_metric-descriptor: ~s" (metric-descriptor self)))
      (cl:format stream " ~_timeseries: ~s" (timeseries self))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_resource: ~s" (resource self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self metric))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'metric-descriptor) cl:nil))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'resource) cl:nil))
  (cl:setf (cl:slot-value self 'timeseries)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::time-series
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self metric))
  cl:t)

(cl:defmethod pb:octet-size ((self metric))
  (cl:let ((size 0))
    ;; .opencensus.proto.metrics.v1.MetricDescriptor metric_descriptor = 1[json_name = "metricDescriptor"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'metric-descriptor))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.resource.v1.Resource resource = 3[json_name = "resource"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'resource))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .opencensus.proto.metrics.v1.TimeSeries timeseries = 2[json_name = "timeseries"];
    (cl:let* ((v (cl:slot-value self 'timeseries))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self metric) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .opencensus.proto.metrics.v1.MetricDescriptor metric_descriptor = 1[json_name = "metricDescriptor"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'metric-descriptor) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'metric-descriptor) buffer index limit)))
  ;; repeated .opencensus.proto.metrics.v1.TimeSeries timeseries = 2[json_name = "timeseries"];
  (cl:let* ((v (cl:slot-value self 'timeseries))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; .opencensus.proto.resource.v1.Resource resource = 3[json_name = "resource"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'resource) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'resource) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self metric) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .opencensus.proto.metrics.v1.MetricDescriptor metric_descriptor = 1[json_name = "metricDescriptor"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'metric-descriptor)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::metric-descriptor))
                (cl:setf (cl:slot-value self 'metric-descriptor) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated .opencensus.proto.metrics.v1.TimeSeries timeseries = 2[json_name = "timeseries"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'opencensus.proto.metrics.v1::time-series)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'timeseries)))))
        ;; .opencensus.proto.resource.v1.Resource resource = 3[json_name = "resource"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'resource)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.resource.v1::resource))
                (cl:setf (cl:slot-value self 'resource) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self metric) (from metric))
  (cl:let* ((v (cl:slot-value self 'timeseries))
            (vf (cl:slot-value from 'timeseries))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'metric-descriptor)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::metric-descriptor))
        (cl:setf (cl:slot-value self 'metric-descriptor) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'metric-descriptor))))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'resource)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.resource.v1::resource))
        (cl:setf (cl:slot-value self 'resource) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'resource))))
)


(cl:defclass metric-descriptor (pb:protocol-buffer)
  (
  (name
   :accessor name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (unit
   :accessor unit
   :initform (pb:string-field "")
   :type pb::%sf%)
  (type
   :accessor type
   :initform opencensus.proto.metrics.v1::+metric-descriptor-type-unspecified+
   :type opencensus.proto.metrics.v1::metric-descriptor-type)
  (label-keys
   :accessor label-keys
   :initform (cl:make-array
              0
              :element-type 'opencensus.proto.metrics.v1::label-key
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector opencensus.proto.metrics.v1::label-key))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'metric-descriptor)

(cl:export 'name)


(cl:defmethod (cl:setf name) :after (x (self metric-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-name)
  (cl:defgeneric has-name (proto)))
(cl:defmethod has-name ((self metric-descriptor))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-name)

(cl:unless (cl:fboundp 'clear-name)
  (cl:defgeneric clear-name (proto)))
(cl:defmethod clear-name ((self metric-descriptor))
  (cl:setf (cl:slot-value self 'name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-name)

(cl:export 'description)


(cl:defmethod (cl:setf description) :after (x (self metric-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self metric-descriptor))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-description)

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self metric-descriptor))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-description)

(cl:export 'unit)


(cl:defmethod (cl:setf unit) :after (x (self metric-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-unit)
  (cl:defgeneric has-unit (proto)))
(cl:defmethod has-unit ((self metric-descriptor))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-unit)

(cl:unless (cl:fboundp 'clear-unit)
  (cl:defgeneric clear-unit (proto)))
(cl:defmethod clear-unit ((self metric-descriptor))
  (cl:setf (cl:slot-value self 'unit) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-unit)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self metric-descriptor))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self metric-descriptor))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self metric-descriptor))
  (cl:setf (cl:slot-value self 'type) opencensus.proto.metrics.v1::+metric-descriptor-type-unspecified+)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)

(cl:export 'label-keys)

(cl:unless (cl:fboundp 'clear-label-keys)
  (cl:defgeneric clear-label-keys (proto)))
(cl:defmethod clear-label-keys ((self metric-descriptor))
  (cl:setf (cl:slot-value self 'label-keys)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::label-key
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-label-keys)


(cl:defmethod cl:print-object ((self metric-descriptor) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_name: ~s" (name self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_unit: ~s" (unit self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      (cl:format stream " ~_label-keys: ~s" (label-keys self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self metric-descriptor))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'unit) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'type) opencensus.proto.metrics.v1::+metric-descriptor-type-unspecified+)
  (cl:setf (cl:slot-value self 'label-keys)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::label-key
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self metric-descriptor))
  cl:t)

(cl:defmethod pb:octet-size ((self metric-descriptor))
  (cl:let ((size 0))
    ;; string name = 1[json_name = "name"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'name))))
        (cl:+ s (varint:length32 s)))))
    ;; string description = 2[json_name = "description"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    ;; string unit = 3[json_name = "unit"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'unit))))
        (cl:+ s (varint:length32 s)))))
    ;; .opencensus.proto.metrics.v1.MetricDescriptor.Type type = 4[json_name = "type"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    ;; repeated .opencensus.proto.metrics.v1.LabelKey label_keys = 5[json_name = "labelKeys"];
    (cl:let* ((v (cl:slot-value self 'label-keys))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self metric-descriptor) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string name = 1[json_name = "name"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'name) 'pb::%octets%))))
  ;; string description = 2[json_name = "description"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  ;; string unit = 3[json_name = "unit"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'unit) 'pb::%octets%))))
  ;; .opencensus.proto.metrics.v1.MetricDescriptor.Type type = 4[json_name = "type"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  ;; repeated .opencensus.proto.metrics.v1.LabelKey label_keys = 5[json_name = "labelKeys"];
  (cl:let* ((v (cl:slot-value self 'label-keys))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self metric-descriptor) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string name = 1[json_name = "name"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string description = 2[json_name = "description"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'description) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string unit = 3[json_name = "unit"];
        ((26)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'unit) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .opencensus.proto.metrics.v1.MetricDescriptor.Type type = 4[json_name = "type"];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; repeated .opencensus.proto.metrics.v1.LabelKey label_keys = 5[json_name = "labelKeys"];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'opencensus.proto.metrics.v1::label-key)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'label-keys)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self metric-descriptor) (from metric-descriptor))
  (cl:let* ((v (cl:slot-value self 'label-keys))
            (vf (cl:slot-value from 'label-keys))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (cl:slot-value from 'name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'unit) (cl:slot-value from 'unit))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass label-key (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'label-key)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self label-key))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self label-key))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self label-key))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'description)


(cl:defmethod (cl:setf description) :after (x (self label-key))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self label-key))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-description)

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self label-key))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-description)


(cl:defmethod cl:print-object ((self label-key) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self label-key))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self label-key))
  cl:t)

(cl:defmethod pb:octet-size ((self label-key))
  (cl:let ((size 0))
    ;; string key = 1[json_name = "key"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; string description = 2[json_name = "description"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self label-key) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string key = 1[json_name = "key"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; string description = 2[json_name = "description"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self label-key) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string key = 1[json_name = "key"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string description = 2[json_name = "description"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'description) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self label-key) (from label-key))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass time-series (pb:protocol-buffer)
  (
  (start-timestamp
   :writer (cl:setf start-timestamp)
   :initform cl:nil
   :type (cl:or cl:null google.protobuf::timestamp))
  (label-values
   :accessor label-values
   :initform (cl:make-array
              0
              :element-type 'opencensus.proto.metrics.v1::label-value
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector opencensus.proto.metrics.v1::label-value))
  (points
   :accessor points
   :initform (cl:make-array
              0
              :element-type 'opencensus.proto.metrics.v1::point
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector opencensus.proto.metrics.v1::point))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'time-series)

(cl:export 'start-timestamp)

(cl:unless (cl:fboundp 'start-timestamp)
  (cl:defgeneric start-timestamp (proto)))
(cl:defmethod start-timestamp ((self time-series))
  (cl:let ((result (cl:slot-value self 'start-timestamp)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'google.protobuf::timestamp))
      (cl:setf (cl:slot-value self 'start-timestamp) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf start-timestamp) :after (x (self time-series))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-start-timestamp)
  (cl:defgeneric has-start-timestamp (proto)))
(cl:defmethod has-start-timestamp ((self time-series))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-start-timestamp)

(cl:unless (cl:fboundp 'clear-start-timestamp)
  (cl:defgeneric clear-start-timestamp (proto)))
(cl:defmethod clear-start-timestamp ((self time-series))
  (cl:setf (cl:slot-value self 'start-timestamp) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-start-timestamp)

(cl:export 'label-values)

(cl:unless (cl:fboundp 'clear-label-values)
  (cl:defgeneric clear-label-values (proto)))
(cl:defmethod clear-label-values ((self time-series))
  (cl:setf (cl:slot-value self 'label-values)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::label-value
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-label-values)

(cl:export 'points)

(cl:unless (cl:fboundp 'clear-points)
  (cl:defgeneric clear-points (proto)))
(cl:defmethod clear-points ((self time-series))
  (cl:setf (cl:slot-value self 'points)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::point
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-points)


(cl:defmethod cl:print-object ((self time-series) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_start-timestamp: ~s" (start-timestamp self)))
      (cl:format stream " ~_label-values: ~s" (label-values self))
      (cl:format stream " ~_points: ~s" (points self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self time-series))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'start-timestamp) cl:nil))
  (cl:setf (cl:slot-value self 'label-values)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::label-value
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'points)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::point
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self time-series))
  cl:t)

(cl:defmethod pb:octet-size ((self time-series))
  (cl:let ((size 0))
    ;; .google.protobuf.Timestamp start_timestamp = 1[json_name = "startTimestamp"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'start-timestamp))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .opencensus.proto.metrics.v1.LabelValue label_values = 2[json_name = "labelValues"];
    (cl:let* ((v (cl:slot-value self 'label-values))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .opencensus.proto.metrics.v1.Point points = 3[json_name = "points"];
    (cl:let* ((v (cl:slot-value self 'points))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self time-series) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .google.protobuf.Timestamp start_timestamp = 1[json_name = "startTimestamp"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'start-timestamp) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'start-timestamp) buffer index limit)))
  ;; repeated .opencensus.proto.metrics.v1.LabelValue label_values = 2[json_name = "labelValues"];
  (cl:let* ((v (cl:slot-value self 'label-values))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; repeated .opencensus.proto.metrics.v1.Point points = 3[json_name = "points"];
  (cl:let* ((v (cl:slot-value self 'points))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self time-series) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .google.protobuf.Timestamp start_timestamp = 1[json_name = "startTimestamp"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'start-timestamp)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'google.protobuf::timestamp))
                (cl:setf (cl:slot-value self 'start-timestamp) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated .opencensus.proto.metrics.v1.LabelValue label_values = 2[json_name = "labelValues"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'opencensus.proto.metrics.v1::label-value)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'label-values)))))
        ;; repeated .opencensus.proto.metrics.v1.Point points = 3[json_name = "points"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'opencensus.proto.metrics.v1::point)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'points)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self time-series) (from time-series))
  (cl:let* ((v (cl:slot-value self 'label-values))
            (vf (cl:slot-value from 'label-values))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'points))
            (vf (cl:slot-value from 'points))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'start-timestamp)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'google.protobuf::timestamp))
        (cl:setf (cl:slot-value self 'start-timestamp) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'start-timestamp))))
)


(cl:defclass label-value (pb:protocol-buffer)
  (
  (value
   :accessor value
   :initform (pb:string-field "")
   :type pb::%sf%)
  (has-value
   :accessor has-value
   :initform cl:nil
   :type cl:boolean)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'label-value)

(cl:export 'value)


(cl:defmethod (cl:setf value) :after (x (self label-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self label-value))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-value)

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self label-value))
  (cl:setf (cl:slot-value self 'value) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-value)

(cl:export 'has-value)


(cl:defmethod (cl:setf has-value) :after (x (self label-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-has-value)
  (cl:defgeneric has-has-value (proto)))
(cl:defmethod has-has-value ((self label-value))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-has-value)

(cl:unless (cl:fboundp 'clear-has-value)
  (cl:defgeneric clear-has-value (proto)))
(cl:defmethod clear-has-value ((self label-value))
  (cl:setf (cl:slot-value self 'has-value) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-has-value)


(cl:defmethod cl:print-object ((self label-value) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_has-value: ~s" (has-value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self label-value))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'has-value) cl:nil)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self label-value))
  cl:t)

(cl:defmethod pb:octet-size ((self label-value))
  (cl:let ((size 0))
    ;; string value = 1[json_name = "value"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'value))))
        (cl:+ s (varint:length32 s)))))
    ;; bool has_value = 2[json_name = "hasValue"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self label-value) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string value = 1[json_name = "value"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'value) 'pb::%octets%))))
  ;; bool has_value = 2[json_name = "hasValue"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'has-value))))
  index)

(cl:defmethod pb:merge-from-array ((self label-value) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string value = 1[json_name = "value"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'value) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; bool has_value = 2[json_name = "hasValue"];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-boolean-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'has-value) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self label-value) (from label-value))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (cl:slot-value from 'value))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'has-value) (cl:slot-value from 'has-value))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass point (pb:protocol-buffer)
  (
  (timestamp
   :writer (cl:setf timestamp)
   :initform cl:nil
   :type (cl:or cl:null google.protobuf::timestamp))
  (int64-value
   :accessor int64-value
   :initform 0
   :type (cl:signed-byte 64))
  (double-value
   :accessor double-value
   :initform 0d0
   :type cl:double-float)
  (distribution-value
   :writer (cl:setf distribution-value)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.metrics.v1::distribution-value))
  (summary-value
   :writer (cl:setf summary-value)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.metrics.v1::summary-value))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'point)

(cl:export 'timestamp)

(cl:unless (cl:fboundp 'timestamp)
  (cl:defgeneric timestamp (proto)))
(cl:defmethod timestamp ((self point))
  (cl:let ((result (cl:slot-value self 'timestamp)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'google.protobuf::timestamp))
      (cl:setf (cl:slot-value self 'timestamp) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf timestamp) :after (x (self point))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-timestamp)
  (cl:defgeneric has-timestamp (proto)))
(cl:defmethod has-timestamp ((self point))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-timestamp)

(cl:unless (cl:fboundp 'clear-timestamp)
  (cl:defgeneric clear-timestamp (proto)))
(cl:defmethod clear-timestamp ((self point))
  (cl:setf (cl:slot-value self 'timestamp) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-timestamp)

(cl:export 'int64-value)


(cl:defmethod (cl:setf int64-value) :after (x (self point))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-int64-value)
  (cl:defgeneric has-int64-value (proto)))
(cl:defmethod has-int64-value ((self point))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-int64-value)

(cl:unless (cl:fboundp 'clear-int64-value)
  (cl:defgeneric clear-int64-value (proto)))
(cl:defmethod clear-int64-value ((self point))
  (cl:setf (cl:slot-value self 'int64-value) 0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-int64-value)

(cl:export 'double-value)


(cl:defmethod (cl:setf double-value) :after (x (self point))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-double-value)
  (cl:defgeneric has-double-value (proto)))
(cl:defmethod has-double-value ((self point))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-double-value)

(cl:unless (cl:fboundp 'clear-double-value)
  (cl:defgeneric clear-double-value (proto)))
(cl:defmethod clear-double-value ((self point))
  (cl:setf (cl:slot-value self 'double-value) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-double-value)

(cl:export 'distribution-value)

(cl:unless (cl:fboundp 'distribution-value)
  (cl:defgeneric distribution-value (proto)))
(cl:defmethod distribution-value ((self point))
  (cl:let ((result (cl:slot-value self 'distribution-value)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value))
      (cl:setf (cl:slot-value self 'distribution-value) result))
      (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf distribution-value) :after (x (self point))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-distribution-value)
  (cl:defgeneric has-distribution-value (proto)))
(cl:defmethod has-distribution-value ((self point))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-distribution-value)

(cl:unless (cl:fboundp 'clear-distribution-value)
  (cl:defgeneric clear-distribution-value (proto)))
(cl:defmethod clear-distribution-value ((self point))
  (cl:setf (cl:slot-value self 'distribution-value) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-distribution-value)

(cl:export 'summary-value)

(cl:unless (cl:fboundp 'summary-value)
  (cl:defgeneric summary-value (proto)))
(cl:defmethod summary-value ((self point))
  (cl:let ((result (cl:slot-value self 'summary-value)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.metrics.v1::summary-value))
      (cl:setf (cl:slot-value self 'summary-value) result))
      (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf summary-value) :after (x (self point))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-summary-value)
  (cl:defgeneric has-summary-value (proto)))
(cl:defmethod has-summary-value ((self point))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-summary-value)

(cl:unless (cl:fboundp 'clear-summary-value)
  (cl:defgeneric clear-summary-value (proto)))
(cl:defmethod clear-summary-value ((self point))
  (cl:setf (cl:slot-value self 'summary-value) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-summary-value)


(cl:defmethod cl:print-object ((self point) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_timestamp: ~s" (timestamp self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_int64-value: ~s" (int64-value self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_double-value: ~s" (double-value self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_distribution-value: ~s" (distribution-value self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_summary-value: ~s" (summary-value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self point))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'timestamp) cl:nil))
  (cl:setf (cl:slot-value self 'int64-value) 0)
  (cl:setf (cl:slot-value self 'double-value) 0d0)
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'distribution-value) cl:nil))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'summary-value) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self point))
  cl:t)

(cl:defmethod pb:octet-size ((self point))
  (cl:let ((size 0))
    ;; .google.protobuf.Timestamp timestamp = 1[json_name = "timestamp"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'timestamp))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; int64 int64_value = 2[json_name = "int64Value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'int64-value))))))
    ;; double double_value = 3[json_name = "doubleValue"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; .opencensus.proto.metrics.v1.DistributionValue distribution_value = 4[json_name = "distributionValue"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'distribution-value))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.metrics.v1.SummaryValue summary_value = 5[json_name = "summaryValue"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'summary-value))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self point) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .google.protobuf.Timestamp timestamp = 1[json_name = "timestamp"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'timestamp) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'timestamp) buffer index limit)))
  ;; int64 int64_value = 2[json_name = "int64Value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'int64-value)))))
  ;; double double_value = 3[json_name = "doubleValue"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 25))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'double-value))))
  ;; .opencensus.proto.metrics.v1.DistributionValue distribution_value = 4[json_name = "distributionValue"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'distribution-value) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'distribution-value) buffer index limit)))
  ;; .opencensus.proto.metrics.v1.SummaryValue summary_value = 5[json_name = "summaryValue"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'summary-value) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'summary-value) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self point) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .google.protobuf.Timestamp timestamp = 1[json_name = "timestamp"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'timestamp)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'google.protobuf::timestamp))
                (cl:setf (cl:slot-value self 'timestamp) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; int64 int64_value = 2[json_name = "int64Value"];
        ((16)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'int64-value) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; double double_value = 3[json_name = "doubleValue"];
        ((25)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'double-value) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .opencensus.proto.metrics.v1.DistributionValue distribution_value = 4[json_name = "distributionValue"];
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'distribution-value)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value))
                (cl:setf (cl:slot-value self 'distribution-value) message)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .opencensus.proto.metrics.v1.SummaryValue summary_value = 5[json_name = "summaryValue"];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'summary-value)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::summary-value))
                (cl:setf (cl:slot-value self 'summary-value) message)
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self point) (from point))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'timestamp)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'google.protobuf::timestamp))
        (cl:setf (cl:slot-value self 'timestamp) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'timestamp))))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'int64-value) (cl:slot-value from 'int64-value))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'double-value) (cl:slot-value from 'double-value))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'distribution-value)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value))
        (cl:setf (cl:slot-value self 'distribution-value) message)
        (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'distribution-value))))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'summary-value)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::summary-value))
        (cl:setf (cl:slot-value self 'summary-value) message)
        (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'summary-value))))
)


(cl:defclass distribution-value-bucket-options-explicit (pb:protocol-buffer)
  (
  (bounds
   :accessor bounds
   :initform (cl:make-array
              0
              :element-type 'cl:double-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:double-float))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'distribution-value-bucket-options-explicit)

(cl:export 'bounds)

(cl:unless (cl:fboundp 'clear-bounds)
  (cl:defgeneric clear-bounds (proto)))
(cl:defmethod clear-bounds ((self distribution-value-bucket-options-explicit))
  (cl:setf (cl:slot-value self 'bounds)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-bounds)



(cl:defclass distribution-value-bucket-options (pb:protocol-buffer)
  (
  (explicit
   :writer (cl:setf explicit)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.metrics.v1::distribution-value-bucket-options-explicit))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'distribution-value-bucket-options)

(cl:export 'explicit)

(cl:unless (cl:fboundp 'explicit)
  (cl:defgeneric explicit (proto)))
(cl:defmethod explicit ((self distribution-value-bucket-options))
  (cl:let ((result (cl:slot-value self 'explicit)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-bucket-options-explicit))
      (cl:setf (cl:slot-value self 'explicit) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf explicit) :after (x (self distribution-value-bucket-options))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-explicit)
  (cl:defgeneric has-explicit (proto)))
(cl:defmethod has-explicit ((self distribution-value-bucket-options))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-explicit)

(cl:unless (cl:fboundp 'clear-explicit)
  (cl:defgeneric clear-explicit (proto)))
(cl:defmethod clear-explicit ((self distribution-value-bucket-options))
  (cl:setf (cl:slot-value self 'explicit) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-explicit)



(cl:defclass distribution-value-bucket (pb:protocol-buffer)
  (
  (count
   :accessor count
   :initform 0
   :type (cl:signed-byte 64))
  (exemplar
   :writer (cl:setf exemplar)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.metrics.v1::distribution-value-exemplar))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'distribution-value-bucket)

(cl:export 'count)


(cl:defmethod (cl:setf count) :after (x (self distribution-value-bucket))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-count)
  (cl:defgeneric has-count (proto)))
(cl:defmethod has-count ((self distribution-value-bucket))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-count)

(cl:unless (cl:fboundp 'clear-count)
  (cl:defgeneric clear-count (proto)))
(cl:defmethod clear-count ((self distribution-value-bucket))
  (cl:setf (cl:slot-value self 'count) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-count)

(cl:export 'exemplar)

(cl:unless (cl:fboundp 'exemplar)
  (cl:defgeneric exemplar (proto)))
(cl:defmethod exemplar ((self distribution-value-bucket))
  (cl:let ((result (cl:slot-value self 'exemplar)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-exemplar))
      (cl:setf (cl:slot-value self 'exemplar) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf exemplar) :after (x (self distribution-value-bucket))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-exemplar)
  (cl:defgeneric has-exemplar (proto)))
(cl:defmethod has-exemplar ((self distribution-value-bucket))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-exemplar)

(cl:unless (cl:fboundp 'clear-exemplar)
  (cl:defgeneric clear-exemplar (proto)))
(cl:defmethod clear-exemplar ((self distribution-value-bucket))
  (cl:setf (cl:slot-value self 'exemplar) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-exemplar)



(cl:defclass distribution-value-exemplar-attachments-entry (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (value
   :accessor value
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'distribution-value-exemplar-attachments-entry)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self distribution-value-exemplar-attachments-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self distribution-value-exemplar-attachments-entry))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self distribution-value-exemplar-attachments-entry))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'value)


(cl:defmethod (cl:setf value) :after (x (self distribution-value-exemplar-attachments-entry))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self distribution-value-exemplar-attachments-entry))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-value)

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self distribution-value-exemplar-attachments-entry))
  (cl:setf (cl:slot-value self 'value) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-value)



(cl:defclass distribution-value-exemplar (pb:protocol-buffer)
  (
  (value
   :accessor value
   :initform 0d0
   :type cl:double-float)
  (timestamp
   :writer (cl:setf timestamp)
   :initform cl:nil
   :type (cl:or cl:null google.protobuf::timestamp))
  (attachments
   :accessor attachments
   :initform (cl:make-array
              0
              :element-type 'opencensus.proto.metrics.v1::distribution-value-exemplar-attachments-entry
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector opencensus.proto.metrics.v1::distribution-value-exemplar-attachments-entry))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'distribution-value-exemplar)

(cl:export 'value)


(cl:defmethod (cl:setf value) :after (x (self distribution-value-exemplar))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self distribution-value-exemplar))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-value)

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self distribution-value-exemplar))
  (cl:setf (cl:slot-value self 'value) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-value)

(cl:export 'timestamp)

(cl:unless (cl:fboundp 'timestamp)
  (cl:defgeneric timestamp (proto)))
(cl:defmethod timestamp ((self distribution-value-exemplar))
  (cl:let ((result (cl:slot-value self 'timestamp)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'google.protobuf::timestamp))
      (cl:setf (cl:slot-value self 'timestamp) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf timestamp) :after (x (self distribution-value-exemplar))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-timestamp)
  (cl:defgeneric has-timestamp (proto)))
(cl:defmethod has-timestamp ((self distribution-value-exemplar))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-timestamp)

(cl:unless (cl:fboundp 'clear-timestamp)
  (cl:defgeneric clear-timestamp (proto)))
(cl:defmethod clear-timestamp ((self distribution-value-exemplar))
  (cl:setf (cl:slot-value self 'timestamp) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-timestamp)

(cl:export 'attachments)

(cl:unless (cl:fboundp 'clear-attachments)
  (cl:defgeneric clear-attachments (proto)))
(cl:defmethod clear-attachments ((self distribution-value-exemplar))
  (cl:setf (cl:slot-value self 'attachments)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::distribution-value-exemplar-attachments-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-attachments)



(cl:defclass distribution-value (pb:protocol-buffer)
  (
  (count
   :accessor count
   :initform 0
   :type (cl:signed-byte 64))
  (sum
   :accessor sum
   :initform 0d0
   :type cl:double-float)
  (sum-of-squared-deviation
   :accessor sum-of-squared-deviation
   :initform 0d0
   :type cl:double-float)
  (bucket-options
   :writer (cl:setf bucket-options)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.metrics.v1::distribution-value-bucket-options))
  (buckets
   :accessor buckets
   :initform (cl:make-array
              0
              :element-type 'opencensus.proto.metrics.v1::distribution-value-bucket
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector opencensus.proto.metrics.v1::distribution-value-bucket))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'distribution-value)

(cl:export 'count)


(cl:defmethod (cl:setf count) :after (x (self distribution-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-count)
  (cl:defgeneric has-count (proto)))
(cl:defmethod has-count ((self distribution-value))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-count)

(cl:unless (cl:fboundp 'clear-count)
  (cl:defgeneric clear-count (proto)))
(cl:defmethod clear-count ((self distribution-value))
  (cl:setf (cl:slot-value self 'count) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-count)

(cl:export 'sum)


(cl:defmethod (cl:setf sum) :after (x (self distribution-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-sum)
  (cl:defgeneric has-sum (proto)))
(cl:defmethod has-sum ((self distribution-value))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-sum)

(cl:unless (cl:fboundp 'clear-sum)
  (cl:defgeneric clear-sum (proto)))
(cl:defmethod clear-sum ((self distribution-value))
  (cl:setf (cl:slot-value self 'sum) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-sum)

(cl:export 'sum-of-squared-deviation)


(cl:defmethod (cl:setf sum-of-squared-deviation) :after (x (self distribution-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-sum-of-squared-deviation)
  (cl:defgeneric has-sum-of-squared-deviation (proto)))
(cl:defmethod has-sum-of-squared-deviation ((self distribution-value))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-sum-of-squared-deviation)

(cl:unless (cl:fboundp 'clear-sum-of-squared-deviation)
  (cl:defgeneric clear-sum-of-squared-deviation (proto)))
(cl:defmethod clear-sum-of-squared-deviation ((self distribution-value))
  (cl:setf (cl:slot-value self 'sum-of-squared-deviation) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-sum-of-squared-deviation)

(cl:export 'bucket-options)

(cl:unless (cl:fboundp 'bucket-options)
  (cl:defgeneric bucket-options (proto)))
(cl:defmethod bucket-options ((self distribution-value))
  (cl:let ((result (cl:slot-value self 'bucket-options)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-bucket-options))
      (cl:setf (cl:slot-value self 'bucket-options) result))
      (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf bucket-options) :after (x (self distribution-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-bucket-options)
  (cl:defgeneric has-bucket-options (proto)))
(cl:defmethod has-bucket-options ((self distribution-value))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-bucket-options)

(cl:unless (cl:fboundp 'clear-bucket-options)
  (cl:defgeneric clear-bucket-options (proto)))
(cl:defmethod clear-bucket-options ((self distribution-value))
  (cl:setf (cl:slot-value self 'bucket-options) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-bucket-options)

(cl:export 'buckets)

(cl:unless (cl:fboundp 'clear-buckets)
  (cl:defgeneric clear-buckets (proto)))
(cl:defmethod clear-buckets ((self distribution-value))
  (cl:setf (cl:slot-value self 'buckets)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::distribution-value-bucket
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-buckets)


(cl:defmethod cl:print-object ((self distribution-value-bucket-options-explicit) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_bounds: ~s" (bounds self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self distribution-value-bucket-options-explicit))
  (cl:setf (cl:slot-value self 'bounds)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self distribution-value-bucket-options-explicit))
  cl:t)

(cl:defmethod pb:octet-size ((self distribution-value-bucket-options-explicit))
  (cl:let ((size 0))
    ;; repeated double bounds = 1[json_name = "bounds"];
    (cl:incf size (cl:* (cl:+ 1 8)
                     (cl:length (cl:slot-value self 'bounds))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self distribution-value-bucket-options-explicit) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated double bounds = 1[json_name = "bounds"];
  (cl:let* ((v (cl:slot-value self 'bounds))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
      (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:aref v i)))))
  index)

(cl:defmethod pb:merge-from-array ((self distribution-value-bucket-options-explicit) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated double bounds = 1[json_name = "bounds"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'bounds))
              (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self distribution-value-bucket-options-explicit) (from distribution-value-bucket-options-explicit))
  (cl:let* ((v (cl:slot-value self 'bounds))
            (vf (cl:slot-value from 'bounds))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
)



(cl:defmethod cl:print-object ((self distribution-value-bucket-options) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_explicit: ~s" (explicit self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self distribution-value-bucket-options))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'explicit) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self distribution-value-bucket-options))
  cl:t)

(cl:defmethod pb:octet-size ((self distribution-value-bucket-options))
  (cl:let ((size 0))
    ;; .opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1[json_name = "explicit"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'explicit))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self distribution-value-bucket-options) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1[json_name = "explicit"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'explicit) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'explicit) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self distribution-value-bucket-options) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .opencensus.proto.metrics.v1.DistributionValue.BucketOptions.Explicit explicit = 1[json_name = "explicit"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'explicit)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-bucket-options-explicit))
                (cl:setf (cl:slot-value self 'explicit) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self distribution-value-bucket-options) (from distribution-value-bucket-options))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'explicit)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-bucket-options-explicit))
        (cl:setf (cl:slot-value self 'explicit) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'explicit))))
)



(cl:defmethod cl:print-object ((self distribution-value-bucket) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_count: ~s" (count self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_exemplar: ~s" (exemplar self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self distribution-value-bucket))
  (cl:setf (cl:slot-value self 'count) 0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'exemplar) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self distribution-value-bucket))
  cl:t)

(cl:defmethod pb:octet-size ((self distribution-value-bucket))
  (cl:let ((size 0))
    ;; int64 count = 1[json_name = "count"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'count))))))
    ;; .opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2[json_name = "exemplar"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'exemplar))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self distribution-value-bucket) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; int64 count = 1[json_name = "count"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'count)))))
  ;; .opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2[json_name = "exemplar"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'exemplar) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'exemplar) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self distribution-value-bucket) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; int64 count = 1[json_name = "count"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'count) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .opencensus.proto.metrics.v1.DistributionValue.Exemplar exemplar = 2[json_name = "exemplar"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'exemplar)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-exemplar))
                (cl:setf (cl:slot-value self 'exemplar) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self distribution-value-bucket) (from distribution-value-bucket))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'count) (cl:slot-value from 'count))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'exemplar)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-exemplar))
        (cl:setf (cl:slot-value self 'exemplar) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'exemplar))))
)



(cl:defmethod cl:print-object ((self distribution-value-exemplar-attachments-entry) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self distribution-value-exemplar-attachments-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self distribution-value-exemplar-attachments-entry))
  cl:t)

(cl:defmethod pb:octet-size ((self distribution-value-exemplar-attachments-entry))
  (cl:let ((size 0))
    ;; string key = 1[json_name = "key"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; string value = 2[json_name = "value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'value))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self distribution-value-exemplar-attachments-entry) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string key = 1[json_name = "key"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; string value = 2[json_name = "value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'value) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self distribution-value-exemplar-attachments-entry) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string key = 1[json_name = "key"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string value = 2[json_name = "value"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'value) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self distribution-value-exemplar-attachments-entry) (from distribution-value-exemplar-attachments-entry))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (cl:slot-value from 'value))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self distribution-value-exemplar) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_timestamp: ~s" (timestamp self)))
      (cl:format stream " ~_attachments: ~s" (attachments self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self distribution-value-exemplar))
  (cl:setf (cl:slot-value self 'value) 0d0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'timestamp) cl:nil))
  (cl:setf (cl:slot-value self 'attachments)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::distribution-value-exemplar-attachments-entry
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self distribution-value-exemplar))
  cl:t)

(cl:defmethod pb:octet-size ((self distribution-value-exemplar))
  (cl:let ((size 0))
    ;; double value = 1[json_name = "value"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; .google.protobuf.Timestamp timestamp = 2[json_name = "timestamp"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'timestamp))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; map<string, string> attachments = 3[json_name = "attachments"];
    (cl:let* ((v (cl:slot-value self 'attachments))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self distribution-value-exemplar) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; double value = 1[json_name = "value"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 9))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'value))))
  ;; .google.protobuf.Timestamp timestamp = 2[json_name = "timestamp"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'timestamp) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'timestamp) buffer index limit)))
  ;; map<string, string> attachments = 3[json_name = "attachments"];
  (cl:let* ((v (cl:slot-value self 'attachments))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self distribution-value-exemplar) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; double value = 1[json_name = "value"];
        ((9)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'value) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .google.protobuf.Timestamp timestamp = 2[json_name = "timestamp"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'timestamp)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'google.protobuf::timestamp))
                (cl:setf (cl:slot-value self 'timestamp) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; map<string, string> attachments = 3[json_name = "attachments"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-exemplar-attachments-entry)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'attachments)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self distribution-value-exemplar) (from distribution-value-exemplar))
  (cl:let* ((v (cl:slot-value self 'attachments))
            (vf (cl:slot-value from 'attachments))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (cl:slot-value from 'value))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'timestamp)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'google.protobuf::timestamp))
        (cl:setf (cl:slot-value self 'timestamp) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'timestamp))))
)



(cl:defmethod cl:print-object ((self distribution-value) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_count: ~s" (count self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_sum: ~s" (sum self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_sum-of-squared-deviation: ~s" (sum-of-squared-deviation self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_bucket-options: ~s" (bucket-options self)))
      (cl:format stream " ~_buckets: ~s" (buckets self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self distribution-value))
  (cl:setf (cl:slot-value self 'count) 0)
  (cl:setf (cl:slot-value self 'sum) 0d0)
  (cl:setf (cl:slot-value self 'sum-of-squared-deviation) 0d0)
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'bucket-options) cl:nil))
  (cl:setf (cl:slot-value self 'buckets)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::distribution-value-bucket
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self distribution-value))
  cl:t)

(cl:defmethod pb:octet-size ((self distribution-value))
  (cl:let ((size 0))
    ;; int64 count = 1[json_name = "count"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'count))))))
    ;; double sum = 2[json_name = "sum"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; double sum_of_squared_deviation = 3[json_name = "sumOfSquaredDeviation"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; .opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4[json_name = "bucketOptions"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'bucket-options))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5[json_name = "buckets"];
    (cl:let* ((v (cl:slot-value self 'buckets))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self distribution-value) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; int64 count = 1[json_name = "count"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'count)))))
  ;; double sum = 2[json_name = "sum"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 17))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'sum))))
  ;; double sum_of_squared_deviation = 3[json_name = "sumOfSquaredDeviation"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 25))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'sum-of-squared-deviation))))
  ;; .opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4[json_name = "bucketOptions"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'bucket-options) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'bucket-options) buffer index limit)))
  ;; repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5[json_name = "buckets"];
  (cl:let* ((v (cl:slot-value self 'buckets))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self distribution-value) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; int64 count = 1[json_name = "count"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'count) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; double sum = 2[json_name = "sum"];
        ((17)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'sum) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; double sum_of_squared_deviation = 3[json_name = "sumOfSquaredDeviation"];
        ((25)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'sum-of-squared-deviation) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .opencensus.proto.metrics.v1.DistributionValue.BucketOptions bucket_options = 4[json_name = "bucketOptions"];
        ((34)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'bucket-options)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-bucket-options))
                (cl:setf (cl:slot-value self 'bucket-options) message)
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated .opencensus.proto.metrics.v1.DistributionValue.Bucket buckets = 5[json_name = "buckets"];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-bucket)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'buckets)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self distribution-value) (from distribution-value))
  (cl:let* ((v (cl:slot-value self 'buckets))
            (vf (cl:slot-value from 'buckets))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'count) (cl:slot-value from 'count))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'sum) (cl:slot-value from 'sum))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'sum-of-squared-deviation) (cl:slot-value from 'sum-of-squared-deviation))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'bucket-options)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::distribution-value-bucket-options))
        (cl:setf (cl:slot-value self 'bucket-options) message)
        (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'bucket-options))))
)


(cl:defclass summary-value-snapshot-value-at-percentile (pb:protocol-buffer)
  (
  (percentile
   :accessor percentile
   :initform 0d0
   :type cl:double-float)
  (value
   :accessor value
   :initform 0d0
   :type cl:double-float)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'summary-value-snapshot-value-at-percentile)

(cl:export 'percentile)


(cl:defmethod (cl:setf percentile) :after (x (self summary-value-snapshot-value-at-percentile))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-percentile)
  (cl:defgeneric has-percentile (proto)))
(cl:defmethod has-percentile ((self summary-value-snapshot-value-at-percentile))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-percentile)

(cl:unless (cl:fboundp 'clear-percentile)
  (cl:defgeneric clear-percentile (proto)))
(cl:defmethod clear-percentile ((self summary-value-snapshot-value-at-percentile))
  (cl:setf (cl:slot-value self 'percentile) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-percentile)

(cl:export 'value)


(cl:defmethod (cl:setf value) :after (x (self summary-value-snapshot-value-at-percentile))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self summary-value-snapshot-value-at-percentile))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-value)

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self summary-value-snapshot-value-at-percentile))
  (cl:setf (cl:slot-value self 'value) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-value)



(cl:defclass summary-value-snapshot (pb:protocol-buffer)
  (
  (count
   :writer (cl:setf count)
   :initform cl:nil
   :type (cl:or cl:null google.protobuf::int64value))
  (sum
   :writer (cl:setf sum)
   :initform cl:nil
   :type (cl:or cl:null google.protobuf::double-value))
  (percentile-values
   :accessor percentile-values
   :initform (cl:make-array
              0
              :element-type 'opencensus.proto.metrics.v1::summary-value-snapshot-value-at-percentile
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector opencensus.proto.metrics.v1::summary-value-snapshot-value-at-percentile))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'summary-value-snapshot)

(cl:export 'count)

(cl:unless (cl:fboundp 'count)
  (cl:defgeneric count (proto)))
(cl:defmethod count ((self summary-value-snapshot))
  (cl:let ((result (cl:slot-value self 'count)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'google.protobuf::int64value))
      (cl:setf (cl:slot-value self 'count) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf count) :after (x (self summary-value-snapshot))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-count)
  (cl:defgeneric has-count (proto)))
(cl:defmethod has-count ((self summary-value-snapshot))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-count)

(cl:unless (cl:fboundp 'clear-count)
  (cl:defgeneric clear-count (proto)))
(cl:defmethod clear-count ((self summary-value-snapshot))
  (cl:setf (cl:slot-value self 'count) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-count)

(cl:export 'sum)

(cl:unless (cl:fboundp 'sum)
  (cl:defgeneric sum (proto)))
(cl:defmethod sum ((self summary-value-snapshot))
  (cl:let ((result (cl:slot-value self 'sum)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'google.protobuf::double-value))
      (cl:setf (cl:slot-value self 'sum) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf sum) :after (x (self summary-value-snapshot))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-sum)
  (cl:defgeneric has-sum (proto)))
(cl:defmethod has-sum ((self summary-value-snapshot))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-sum)

(cl:unless (cl:fboundp 'clear-sum)
  (cl:defgeneric clear-sum (proto)))
(cl:defmethod clear-sum ((self summary-value-snapshot))
  (cl:setf (cl:slot-value self 'sum) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-sum)

(cl:export 'percentile-values)

(cl:unless (cl:fboundp 'clear-percentile-values)
  (cl:defgeneric clear-percentile-values (proto)))
(cl:defmethod clear-percentile-values ((self summary-value-snapshot))
  (cl:setf (cl:slot-value self 'percentile-values)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::summary-value-snapshot-value-at-percentile
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-percentile-values)



(cl:defclass summary-value (pb:protocol-buffer)
  (
  (count
   :writer (cl:setf count)
   :initform cl:nil
   :type (cl:or cl:null google.protobuf::int64value))
  (sum
   :writer (cl:setf sum)
   :initform cl:nil
   :type (cl:or cl:null google.protobuf::double-value))
  (snapshot
   :writer (cl:setf snapshot)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.metrics.v1::summary-value-snapshot))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 3))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'summary-value)

(cl:export 'count)

(cl:unless (cl:fboundp 'count)
  (cl:defgeneric count (proto)))
(cl:defmethod count ((self summary-value))
  (cl:let ((result (cl:slot-value self 'count)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'google.protobuf::int64value))
      (cl:setf (cl:slot-value self 'count) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf count) :after (x (self summary-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-count)
  (cl:defgeneric has-count (proto)))
(cl:defmethod has-count ((self summary-value))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-count)

(cl:unless (cl:fboundp 'clear-count)
  (cl:defgeneric clear-count (proto)))
(cl:defmethod clear-count ((self summary-value))
  (cl:setf (cl:slot-value self 'count) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-count)

(cl:export 'sum)

(cl:unless (cl:fboundp 'sum)
  (cl:defgeneric sum (proto)))
(cl:defmethod sum ((self summary-value))
  (cl:let ((result (cl:slot-value self 'sum)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'google.protobuf::double-value))
      (cl:setf (cl:slot-value self 'sum) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf sum) :after (x (self summary-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-sum)
  (cl:defgeneric has-sum (proto)))
(cl:defmethod has-sum ((self summary-value))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-sum)

(cl:unless (cl:fboundp 'clear-sum)
  (cl:defgeneric clear-sum (proto)))
(cl:defmethod clear-sum ((self summary-value))
  (cl:setf (cl:slot-value self 'sum) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-sum)

(cl:export 'snapshot)

(cl:unless (cl:fboundp 'snapshot)
  (cl:defgeneric snapshot (proto)))
(cl:defmethod snapshot ((self summary-value))
  (cl:let ((result (cl:slot-value self 'snapshot)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.metrics.v1::summary-value-snapshot))
      (cl:setf (cl:slot-value self 'snapshot) result))
      (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf snapshot) :after (x (self summary-value))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-snapshot)
  (cl:defgeneric has-snapshot (proto)))
(cl:defmethod has-snapshot ((self summary-value))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-snapshot)

(cl:unless (cl:fboundp 'clear-snapshot)
  (cl:defgeneric clear-snapshot (proto)))
(cl:defmethod clear-snapshot ((self summary-value))
  (cl:setf (cl:slot-value self 'snapshot) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-snapshot)


(cl:defmethod cl:print-object ((self summary-value-snapshot-value-at-percentile) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_percentile: ~s" (percentile self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self summary-value-snapshot-value-at-percentile))
  (cl:setf (cl:slot-value self 'percentile) 0d0)
  (cl:setf (cl:slot-value self 'value) 0d0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self summary-value-snapshot-value-at-percentile))
  cl:t)

(cl:defmethod pb:octet-size ((self summary-value-snapshot-value-at-percentile))
  (cl:let ((size 0))
    ;; double percentile = 1[json_name = "percentile"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; double value = 2[json_name = "value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self summary-value-snapshot-value-at-percentile) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; double percentile = 1[json_name = "percentile"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 9))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'percentile))))
  ;; double value = 2[json_name = "value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 17))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'value))))
  index)

(cl:defmethod pb:merge-from-array ((self summary-value-snapshot-value-at-percentile) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; double percentile = 1[json_name = "percentile"];
        ((9)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'percentile) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; double value = 2[json_name = "value"];
        ((17)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'value) value)
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self summary-value-snapshot-value-at-percentile) (from summary-value-snapshot-value-at-percentile))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'percentile) (cl:slot-value from 'percentile))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (cl:slot-value from 'value))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)



(cl:defmethod cl:print-object ((self summary-value-snapshot) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_count: ~s" (count self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_sum: ~s" (sum self)))
      (cl:format stream " ~_percentile-values: ~s" (percentile-values self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self summary-value-snapshot))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'count) cl:nil))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'sum) cl:nil))
  (cl:setf (cl:slot-value self 'percentile-values)
           (cl:make-array 0 :element-type 'opencensus.proto.metrics.v1::summary-value-snapshot-value-at-percentile
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self summary-value-snapshot))
  cl:t)

(cl:defmethod pb:octet-size ((self summary-value-snapshot))
  (cl:let ((size 0))
    ;; .google.protobuf.Int64Value count = 1[json_name = "count"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'count))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .google.protobuf.DoubleValue sum = 2[json_name = "sum"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'sum))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .opencensus.proto.metrics.v1.SummaryValue.Snapshot.ValueAtPercentile percentile_values = 3[json_name = "percentileValues"];
    (cl:let* ((v (cl:slot-value self 'percentile-values))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self summary-value-snapshot) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .google.protobuf.Int64Value count = 1[json_name = "count"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'count) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'count) buffer index limit)))
  ;; .google.protobuf.DoubleValue sum = 2[json_name = "sum"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'sum) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'sum) buffer index limit)))
  ;; repeated .opencensus.proto.metrics.v1.SummaryValue.Snapshot.ValueAtPercentile percentile_values = 3[json_name = "percentileValues"];
  (cl:let* ((v (cl:slot-value self 'percentile-values))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self summary-value-snapshot) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .google.protobuf.Int64Value count = 1[json_name = "count"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'count)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'google.protobuf::int64value))
                (cl:setf (cl:slot-value self 'count) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .google.protobuf.DoubleValue sum = 2[json_name = "sum"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'sum)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'google.protobuf::double-value))
                (cl:setf (cl:slot-value self 'sum) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated .opencensus.proto.metrics.v1.SummaryValue.Snapshot.ValueAtPercentile percentile_values = 3[json_name = "percentileValues"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'opencensus.proto.metrics.v1::summary-value-snapshot-value-at-percentile)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'percentile-values)))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self summary-value-snapshot) (from summary-value-snapshot))
  (cl:let* ((v (cl:slot-value self 'percentile-values))
            (vf (cl:slot-value from 'percentile-values))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'count)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'google.protobuf::int64value))
        (cl:setf (cl:slot-value self 'count) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'count))))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'sum)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'google.protobuf::double-value))
        (cl:setf (cl:slot-value self 'sum) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'sum))))
)



(cl:defmethod cl:print-object ((self summary-value) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_count: ~s" (count self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_sum: ~s" (sum self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_snapshot: ~s" (snapshot self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self summary-value))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'count) cl:nil))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'sum) cl:nil))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'snapshot) cl:nil))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self summary-value))
  cl:t)

(cl:defmethod pb:octet-size ((self summary-value))
  (cl:let ((size 0))
    ;; .google.protobuf.Int64Value count = 1[json_name = "count"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'count))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .google.protobuf.DoubleValue sum = 2[json_name = "sum"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'sum))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.metrics.v1.SummaryValue.Snapshot snapshot = 3[json_name = "snapshot"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'snapshot))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self summary-value) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .google.protobuf.Int64Value count = 1[json_name = "count"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'count) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'count) buffer index limit)))
  ;; .google.protobuf.DoubleValue sum = 2[json_name = "sum"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'sum) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'sum) buffer index limit)))
  ;; .opencensus.proto.metrics.v1.SummaryValue.Snapshot snapshot = 3[json_name = "snapshot"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'snapshot) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'snapshot) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self summary-value) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .google.protobuf.Int64Value count = 1[json_name = "count"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'count)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'google.protobuf::int64value))
                (cl:setf (cl:slot-value self 'count) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .google.protobuf.DoubleValue sum = 2[json_name = "sum"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'sum)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'google.protobuf::double-value))
                (cl:setf (cl:slot-value self 'sum) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .opencensus.proto.metrics.v1.SummaryValue.Snapshot snapshot = 3[json_name = "snapshot"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'snapshot)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::summary-value-snapshot))
                (cl:setf (cl:slot-value self 'snapshot) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self summary-value) (from summary-value))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'count)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'google.protobuf::int64value))
        (cl:setf (cl:slot-value self 'count) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'count))))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'sum)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'google.protobuf::double-value))
        (cl:setf (cl:slot-value self 'sum) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'sum))))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'snapshot)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.metrics.v1::summary-value-snapshot))
        (cl:setf (cl:slot-value self 'snapshot) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'snapshot))))
)


