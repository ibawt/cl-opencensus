
;;;;    opencensus/proto/stats/v1/stats.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:opencensus.proto.stats.v1)
    (make-package '#:opencensus.proto.stats.v1 :use nil)))
(in-package #:opencensus.proto.stats.v1)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:deftype measure-type () '(cl:member 0 1 2))
(cl:export 'measure-type)

(cl:defconstant +measure-type-type-unspecified+ 0)
(cl:export '+measure-type-type-unspecified+)
(cl:defconstant +measure-type-int64+ 1)
(cl:export '+measure-type-int64+)
(cl:defconstant +measure-type-double+ 2)
(cl:export '+measure-type-double+)

(cl:defconstant +minimum-measure-type+ +measure-type-type-unspecified+)
(cl:export '+minimum-measure-type+)
(cl:defconstant +maximum-measure-type+ +measure-type-double+)
(cl:export '+maximum-measure-type+)

(cl:defclass tag (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (value
   :accessor value
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'tag)

(cl:export 'key)


(cl:defmethod (cl:setf key) :after (x (self tag))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self tag))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-key)

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self tag))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-key)

(cl:export 'value)


(cl:defmethod (cl:setf value) :after (x (self tag))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self tag))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-value)

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self tag))
  (cl:setf (cl:slot-value self 'value) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-value)


(cl:defmethod cl:print-object ((self tag) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self tag))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self tag))
  cl:t)

(cl:defmethod pb:octet-size ((self tag))
  (cl:let ((size 0))
    ;; string key = 1[json_name = "key"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; string value = 2[json_name = "value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'value))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self tag) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string key = 1[json_name = "key"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; string value = 2[json_name = "value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'value) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self tag) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string key = 1[json_name = "key"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'key) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string value = 2[json_name = "value"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'value) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self tag) (from tag))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (cl:slot-value from 'value))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass measure (pb:protocol-buffer)
  (
  (name
   :accessor name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (unit
   :accessor unit
   :initform (pb:string-field "")
   :type pb::%sf%)
  (type
   :accessor type
   :initform opencensus.proto.stats.v1::+measure-type-type-unspecified+
   :type opencensus.proto.stats.v1::measure-type)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 4))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'measure)

(cl:export 'name)


(cl:defmethod (cl:setf name) :after (x (self measure))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-name)
  (cl:defgeneric has-name (proto)))
(cl:defmethod has-name ((self measure))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-name)

(cl:unless (cl:fboundp 'clear-name)
  (cl:defgeneric clear-name (proto)))
(cl:defmethod clear-name ((self measure))
  (cl:setf (cl:slot-value self 'name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-name)

(cl:export 'description)


(cl:defmethod (cl:setf description) :after (x (self measure))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self measure))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-description)

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self measure))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-description)

(cl:export 'unit)


(cl:defmethod (cl:setf unit) :after (x (self measure))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-unit)
  (cl:defgeneric has-unit (proto)))
(cl:defmethod has-unit ((self measure))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-unit)

(cl:unless (cl:fboundp 'clear-unit)
  (cl:defgeneric clear-unit (proto)))
(cl:defmethod clear-unit ((self measure))
  (cl:setf (cl:slot-value self 'unit) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-unit)

(cl:export 'type)


(cl:defmethod (cl:setf type) :after (x (self measure))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-type)
  (cl:defgeneric has-type (proto)))
(cl:defmethod has-type ((self measure))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-type)

(cl:unless (cl:fboundp 'clear-type)
  (cl:defgeneric clear-type (proto)))
(cl:defmethod clear-type ((self measure))
  (cl:setf (cl:slot-value self 'type) opencensus.proto.stats.v1::+measure-type-type-unspecified+)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-type)


(cl:defmethod cl:print-object ((self measure) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_name: ~s" (name self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_unit: ~s" (unit self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_type: ~s" (type self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self measure))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'unit) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'type) opencensus.proto.stats.v1::+measure-type-type-unspecified+)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self measure))
  cl:t)

(cl:defmethod pb:octet-size ((self measure))
  (cl:let ((size 0))
    ;; string name = 1[json_name = "name"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'name))))
        (cl:+ s (varint:length32 s)))))
    ;; string description = 2[json_name = "description"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    ;; string unit = 3[json_name = "unit"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'unit))))
        (cl:+ s (varint:length32 s)))))
    ;; .opencensus.proto.stats.v1.Measure.Type type = 4[json_name = "type"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self measure) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string name = 1[json_name = "name"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'name) 'pb::%octets%))))
  ;; string description = 2[json_name = "description"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  ;; string unit = 3[json_name = "unit"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'unit) 'pb::%octets%))))
  ;; .opencensus.proto.stats.v1.Measure.Type type = 4[json_name = "type"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'type)))))
  index)

(cl:defmethod pb:merge-from-array ((self measure) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string name = 1[json_name = "name"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string description = 2[json_name = "description"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'description) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string unit = 3[json_name = "unit"];
        ((26)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'unit) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .opencensus.proto.stats.v1.Measure.Type type = 4[json_name = "type"];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'type) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self measure) (from measure))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (cl:slot-value from 'name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'unit) (cl:slot-value from 'unit))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'type) (cl:slot-value from 'type))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass view (pb:protocol-buffer)
  (
  (name
   :accessor name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (measure
   :writer (cl:setf measure)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.stats.v1::measure))
  (columns
   :accessor columns
   :initform (cl:make-array
              0
              :element-type 'pb::%sf%
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector pb::%sf%))
  (count-aggregation
   :writer (cl:setf count-aggregation)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.stats.v1::count-aggregation))
  (sum-aggregation
   :writer (cl:setf sum-aggregation)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.stats.v1::sum-aggregation))
  (last-value-aggregation
   :writer (cl:setf last-value-aggregation)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.stats.v1::last-value-aggregation))
  (distribution-aggregation
   :writer (cl:setf distribution-aggregation)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.stats.v1::distribution-aggregation))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 8))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'view)

(cl:export 'name)


(cl:defmethod (cl:setf name) :after (x (self view))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-name)
  (cl:defgeneric has-name (proto)))
(cl:defmethod has-name ((self view))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-name)

(cl:unless (cl:fboundp 'clear-name)
  (cl:defgeneric clear-name (proto)))
(cl:defmethod clear-name ((self view))
  (cl:setf (cl:slot-value self 'name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-name)

(cl:export 'description)


(cl:defmethod (cl:setf description) :after (x (self view))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self view))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-description)

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self view))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-description)

(cl:export 'measure)

(cl:unless (cl:fboundp 'measure)
  (cl:defgeneric measure (proto)))
(cl:defmethod measure ((self view))
  (cl:let ((result (cl:slot-value self 'measure)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.stats.v1::measure))
      (cl:setf (cl:slot-value self 'measure) result))
      (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf measure) :after (x (self view))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-measure)
  (cl:defgeneric has-measure (proto)))
(cl:defmethod has-measure ((self view))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-measure)

(cl:unless (cl:fboundp 'clear-measure)
  (cl:defgeneric clear-measure (proto)))
(cl:defmethod clear-measure ((self view))
  (cl:setf (cl:slot-value self 'measure) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-measure)

(cl:export 'columns)

(cl:unless (cl:fboundp 'clear-columns)
  (cl:defgeneric clear-columns (proto)))
(cl:defmethod clear-columns ((self view))
  (cl:setf (cl:slot-value self 'columns)
           (cl:make-array
            0
            :element-type 'pb::%sf%
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-columns)

(cl:export 'count-aggregation)

(cl:unless (cl:fboundp 'count-aggregation)
  (cl:defgeneric count-aggregation (proto)))
(cl:defmethod count-aggregation ((self view))
  (cl:let ((result (cl:slot-value self 'count-aggregation)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.stats.v1::count-aggregation))
      (cl:setf (cl:slot-value self 'count-aggregation) result))
      (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf count-aggregation) :after (x (self view))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-count-aggregation)
  (cl:defgeneric has-count-aggregation (proto)))
(cl:defmethod has-count-aggregation ((self view))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-count-aggregation)

(cl:unless (cl:fboundp 'clear-count-aggregation)
  (cl:defgeneric clear-count-aggregation (proto)))
(cl:defmethod clear-count-aggregation ((self view))
  (cl:setf (cl:slot-value self 'count-aggregation) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-count-aggregation)

(cl:export 'sum-aggregation)

(cl:unless (cl:fboundp 'sum-aggregation)
  (cl:defgeneric sum-aggregation (proto)))
(cl:defmethod sum-aggregation ((self view))
  (cl:let ((result (cl:slot-value self 'sum-aggregation)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.stats.v1::sum-aggregation))
      (cl:setf (cl:slot-value self 'sum-aggregation) result))
      (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf sum-aggregation) :after (x (self view))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-sum-aggregation)
  (cl:defgeneric has-sum-aggregation (proto)))
(cl:defmethod has-sum-aggregation ((self view))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-sum-aggregation)

(cl:unless (cl:fboundp 'clear-sum-aggregation)
  (cl:defgeneric clear-sum-aggregation (proto)))
(cl:defmethod clear-sum-aggregation ((self view))
  (cl:setf (cl:slot-value self 'sum-aggregation) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-sum-aggregation)

(cl:export 'last-value-aggregation)

(cl:unless (cl:fboundp 'last-value-aggregation)
  (cl:defgeneric last-value-aggregation (proto)))
(cl:defmethod last-value-aggregation ((self view))
  (cl:let ((result (cl:slot-value self 'last-value-aggregation)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.stats.v1::last-value-aggregation))
      (cl:setf (cl:slot-value self 'last-value-aggregation) result))
      (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf last-value-aggregation) :after (x (self view))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-last-value-aggregation)
  (cl:defgeneric has-last-value-aggregation (proto)))
(cl:defmethod has-last-value-aggregation ((self view))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-last-value-aggregation)

(cl:unless (cl:fboundp 'clear-last-value-aggregation)
  (cl:defgeneric clear-last-value-aggregation (proto)))
(cl:defmethod clear-last-value-aggregation ((self view))
  (cl:setf (cl:slot-value self 'last-value-aggregation) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-last-value-aggregation)

(cl:export 'distribution-aggregation)

(cl:unless (cl:fboundp 'distribution-aggregation)
  (cl:defgeneric distribution-aggregation (proto)))
(cl:defmethod distribution-aggregation ((self view))
  (cl:let ((result (cl:slot-value self 'distribution-aggregation)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.stats.v1::distribution-aggregation))
      (cl:setf (cl:slot-value self 'distribution-aggregation) result))
      (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf distribution-aggregation) :after (x (self view))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-distribution-aggregation)
  (cl:defgeneric has-distribution-aggregation (proto)))
(cl:defmethod has-distribution-aggregation ((self view))
  (cl:logbitp 7 (cl:slot-value self '%has-bits%)))
(cl:export 'has-distribution-aggregation)

(cl:unless (cl:fboundp 'clear-distribution-aggregation)
  (cl:defgeneric clear-distribution-aggregation (proto)))
(cl:defmethod clear-distribution-aggregation ((self view))
  (cl:setf (cl:slot-value self 'distribution-aggregation) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-distribution-aggregation)


(cl:defmethod cl:print-object ((self view) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_name: ~s" (name self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_measure: ~s" (measure self)))
      (cl:format stream " ~_columns: ~s" (columns self))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_count-aggregation: ~s" (count-aggregation self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_sum-aggregation: ~s" (sum-aggregation self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_last-value-aggregation: ~s" (last-value-aggregation self)))
      (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_distribution-aggregation: ~s" (distribution-aggregation self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self view))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'measure) cl:nil))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'count-aggregation) cl:nil))
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'sum-aggregation) cl:nil))
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'last-value-aggregation) cl:nil))
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'distribution-aggregation) cl:nil))
  (cl:setf (cl:slot-value self 'columns)
           (cl:make-array
            0
            :element-type 'pb::%sf%
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self view))
  cl:t)

(cl:defmethod pb:octet-size ((self view))
  (cl:let ((size 0))
    ;; string name = 1[json_name = "name"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'name))))
        (cl:+ s (varint:length32 s)))))
    ;; string description = 2[json_name = "description"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    ;; .opencensus.proto.stats.v1.Measure measure = 3[json_name = "measure"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'measure))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.stats.v1.CountAggregation count_aggregation = 5[json_name = "countAggregation"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'count-aggregation))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.stats.v1.SumAggregation sum_aggregation = 6[json_name = "sumAggregation"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'sum-aggregation))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.stats.v1.LastValueAggregation last_value_aggregation = 7[json_name = "lastValueAggregation"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'last-value-aggregation))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.stats.v1.DistributionAggregation distribution_aggregation = 8[json_name = "distributionAggregation"];
    (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'distribution-aggregation))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated string columns = 4[json_name = "columns"];
    (cl:let* ((x (cl:slot-value self 'columns))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:aref x i))))
  (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self view) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; string name = 1[json_name = "name"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'name) 'pb::%octets%))))
  ;; string description = 2[json_name = "description"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  ;; .opencensus.proto.stats.v1.Measure measure = 3[json_name = "measure"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'measure) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'measure) buffer index limit)))
  ;; repeated string columns = 4[json_name = "columns"];
  (cl:let* ((v (cl:slot-value self 'columns))
            (length (cl:length v)))
    (cl:dotimes (i length)
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
      (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%octets%)))))
  ;; .opencensus.proto.stats.v1.CountAggregation count_aggregation = 5[json_name = "countAggregation"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'count-aggregation) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'count-aggregation) buffer index limit)))
  ;; .opencensus.proto.stats.v1.SumAggregation sum_aggregation = 6[json_name = "sumAggregation"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'sum-aggregation) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'sum-aggregation) buffer index limit)))
  ;; .opencensus.proto.stats.v1.LastValueAggregation last_value_aggregation = 7[json_name = "lastValueAggregation"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'last-value-aggregation) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'last-value-aggregation) buffer index limit)))
  ;; .opencensus.proto.stats.v1.DistributionAggregation distribution_aggregation = 8[json_name = "distributionAggregation"];
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 66))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'distribution-aggregation) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'distribution-aggregation) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self view) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; string name = 1[json_name = "name"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; string description = 2[json_name = "description"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'description) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .opencensus.proto.stats.v1.Measure measure = 3[json_name = "measure"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'measure)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::measure))
                (cl:setf (cl:slot-value self 'measure) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; repeated string columns = 4[json_name = "columns"];
        ((34)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:vector-push-extend (pb:string-field value) (cl:slot-value self 'columns))
            (cl:setf index new-index)))
        ;; .opencensus.proto.stats.v1.CountAggregation count_aggregation = 5[json_name = "countAggregation"];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'count-aggregation)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::count-aggregation))
                (cl:setf (cl:slot-value self 'count-aggregation) message)
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .opencensus.proto.stats.v1.SumAggregation sum_aggregation = 6[json_name = "sumAggregation"];
        ((50)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'sum-aggregation)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::sum-aggregation))
                (cl:setf (cl:slot-value self 'sum-aggregation) message)
                (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .opencensus.proto.stats.v1.LastValueAggregation last_value_aggregation = 7[json_name = "lastValueAggregation"];
        ((58)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'last-value-aggregation)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::last-value-aggregation))
                (cl:setf (cl:slot-value self 'last-value-aggregation) message)
                (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .opencensus.proto.stats.v1.DistributionAggregation distribution_aggregation = 8[json_name = "distributionAggregation"];
        ((66)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'distribution-aggregation)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::distribution-aggregation))
                (cl:setf (cl:slot-value self 'distribution-aggregation) message)
                (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self view) (from view))
  (cl:let ((v (cl:slot-value self 'columns))
           (vf (cl:slot-value from 'columns)))
    (cl:dotimes (i (cl:length vf))
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'name) (cl:slot-value from 'name))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'measure)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::measure))
        (cl:setf (cl:slot-value self 'measure) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'measure))))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'count-aggregation)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::count-aggregation))
        (cl:setf (cl:slot-value self 'count-aggregation) message)
        (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'count-aggregation))))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'sum-aggregation)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::sum-aggregation))
        (cl:setf (cl:slot-value self 'sum-aggregation) message)
        (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'sum-aggregation))))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'last-value-aggregation)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::last-value-aggregation))
        (cl:setf (cl:slot-value self 'last-value-aggregation) message)
        (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'last-value-aggregation))))
  (cl:when (cl:logbitp 7 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'distribution-aggregation)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.stats.v1::distribution-aggregation))
        (cl:setf (cl:slot-value self 'distribution-aggregation) message)
        (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'distribution-aggregation))))
)


(cl:defclass count-aggregation (pb:protocol-buffer)
  (
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'count-aggregation)


(cl:defmethod cl:print-object ((self count-aggregation) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      ))
  (cl:values))

(cl:defmethod pb:clear ((self count-aggregation))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self count-aggregation))
  cl:t)

(cl:defmethod pb:octet-size ((self count-aggregation))
  (cl:let ((size 0))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self count-aggregation) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  index)

(cl:defmethod pb:merge-from-array ((self count-aggregation) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self count-aggregation) (from count-aggregation))
)


(cl:defclass sum-aggregation (pb:protocol-buffer)
  (
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'sum-aggregation)


(cl:defmethod cl:print-object ((self sum-aggregation) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      ))
  (cl:values))

(cl:defmethod pb:clear ((self sum-aggregation))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self sum-aggregation))
  cl:t)

(cl:defmethod pb:octet-size ((self sum-aggregation))
  (cl:let ((size 0))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self sum-aggregation) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  index)

(cl:defmethod pb:merge-from-array ((self sum-aggregation) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self sum-aggregation) (from sum-aggregation))
)


(cl:defclass last-value-aggregation (pb:protocol-buffer)
  (
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'last-value-aggregation)


(cl:defmethod cl:print-object ((self last-value-aggregation) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      ))
  (cl:values))

(cl:defmethod pb:clear ((self last-value-aggregation))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self last-value-aggregation))
  cl:t)

(cl:defmethod pb:octet-size ((self last-value-aggregation))
  (cl:let ((size 0))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self last-value-aggregation) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  index)

(cl:defmethod pb:merge-from-array ((self last-value-aggregation) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self last-value-aggregation) (from last-value-aggregation))
)


(cl:defclass distribution-aggregation (pb:protocol-buffer)
  (
  (bucket-bounds
   :accessor bucket-bounds
   :initform (cl:make-array
              0
              :element-type 'cl:double-float
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector cl:double-float))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'distribution-aggregation)

(cl:export 'bucket-bounds)

(cl:unless (cl:fboundp 'clear-bucket-bounds)
  (cl:defgeneric clear-bucket-bounds (proto)))
(cl:defmethod clear-bucket-bounds ((self distribution-aggregation))
  (cl:setf (cl:slot-value self 'bucket-bounds)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-bucket-bounds)


(cl:defmethod cl:print-object ((self distribution-aggregation) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_bucket-bounds: ~s" (bucket-bounds self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self distribution-aggregation))
  (cl:setf (cl:slot-value self 'bucket-bounds)
           (cl:make-array 0 :element-type 'cl:double-float
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self distribution-aggregation))
  cl:t)

(cl:defmethod pb:octet-size ((self distribution-aggregation))
  (cl:let ((size 0))
    ;; repeated double bucket_bounds = 1[json_name = "bucketBounds"];
    (cl:incf size (cl:* (cl:+ 1 8)
                     (cl:length (cl:slot-value self 'bucket-bounds))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self distribution-aggregation) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated double bucket_bounds = 1[json_name = "bucketBounds"];
  (cl:let* ((v (cl:slot-value self 'bucket-bounds))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
      (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:aref v i)))))
  index)

(cl:defmethod pb:merge-from-array ((self distribution-aggregation) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated double bucket_bounds = 1[json_name = "bucketBounds"];
        ((10)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
              (cl:vector-push-extend value (cl:slot-value self 'bucket-bounds))
              (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self distribution-aggregation) (from distribution-aggregation))
  (cl:let* ((v (cl:slot-value self 'bucket-bounds))
            (vf (cl:slot-value from 'bucket-bounds))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
)


(cl:defclass measurement (pb:protocol-buffer)
  (
  (tags
   :accessor tags
   :initform (cl:make-array
              0
              :element-type 'opencensus.proto.stats.v1::tag
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector opencensus.proto.stats.v1::tag))
  (measure-name
   :accessor measure-name
   :initform (pb:string-field "")
   :type pb::%sf%)
  (double-value
   :accessor double-value
   :initform 0d0
   :type cl:double-float)
  (int-value
   :accessor int-value
   :initform 0
   :type (cl:signed-byte 64))
  (time
   :writer (cl:setf time)
   :initform cl:nil
   :type (cl:or cl:null google.protobuf::timestamp))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'measurement)

(cl:export 'tags)

(cl:unless (cl:fboundp 'clear-tags)
  (cl:defgeneric clear-tags (proto)))
(cl:defmethod clear-tags ((self measurement))
  (cl:setf (cl:slot-value self 'tags)
           (cl:make-array 0 :element-type 'opencensus.proto.stats.v1::tag
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:export 'clear-tags)

(cl:export 'measure-name)


(cl:defmethod (cl:setf measure-name) :after (x (self measurement))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-measure-name)
  (cl:defgeneric has-measure-name (proto)))
(cl:defmethod has-measure-name ((self measurement))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-measure-name)

(cl:unless (cl:fboundp 'clear-measure-name)
  (cl:defgeneric clear-measure-name (proto)))
(cl:defmethod clear-measure-name ((self measurement))
  (cl:setf (cl:slot-value self 'measure-name) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-measure-name)

(cl:export 'double-value)


(cl:defmethod (cl:setf double-value) :after (x (self measurement))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-double-value)
  (cl:defgeneric has-double-value (proto)))
(cl:defmethod has-double-value ((self measurement))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-double-value)

(cl:unless (cl:fboundp 'clear-double-value)
  (cl:defgeneric clear-double-value (proto)))
(cl:defmethod clear-double-value ((self measurement))
  (cl:setf (cl:slot-value self 'double-value) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-double-value)

(cl:export 'int-value)


(cl:defmethod (cl:setf int-value) :after (x (self measurement))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-int-value)
  (cl:defgeneric has-int-value (proto)))
(cl:defmethod has-int-value ((self measurement))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-int-value)

(cl:unless (cl:fboundp 'clear-int-value)
  (cl:defgeneric clear-int-value (proto)))
(cl:defmethod clear-int-value ((self measurement))
  (cl:setf (cl:slot-value self 'int-value) 0)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-int-value)

(cl:export 'time)

(cl:unless (cl:fboundp 'time)
  (cl:defgeneric time (proto)))
(cl:defmethod time ((self measurement))
  (cl:let ((result (cl:slot-value self 'time)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'google.protobuf::timestamp))
      (cl:setf (cl:slot-value self 'time) result))
      (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf time) :after (x (self measurement))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-time)
  (cl:defgeneric has-time (proto)))
(cl:defmethod has-time ((self measurement))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-time)

(cl:unless (cl:fboundp 'clear-time)
  (cl:defgeneric clear-time (proto)))
(cl:defmethod clear-time ((self measurement))
  (cl:setf (cl:slot-value self 'time) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-time)


(cl:defmethod cl:print-object ((self measurement) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:format stream " ~_tags: ~s" (tags self))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_measure-name: ~s" (measure-name self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_double-value: ~s" (double-value self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_int-value: ~s" (int-value self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_time: ~s" (time self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self measurement))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'measure-name) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'double-value) 0d0)
  (cl:setf (cl:slot-value self 'int-value) 0)
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'time) cl:nil))
  (cl:setf (cl:slot-value self 'tags)
           (cl:make-array 0 :element-type 'opencensus.proto.stats.v1::tag
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self measurement))
  cl:t)

(cl:defmethod pb:octet-size ((self measurement))
  (cl:let ((size 0))
    ;; string measure_name = 2[json_name = "measureName"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'measure-name))))
        (cl:+ s (varint:length32 s)))))
    ;; double double_value = 3[json_name = "doubleValue"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; int64 int_value = 4[json_name = "intValue"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'int-value))))))
    ;; .google.protobuf.Timestamp time = 5[json_name = "time"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'time))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .opencensus.proto.stats.v1.Tag tags = 1[json_name = "tags"];
    (cl:let* ((v (cl:slot-value self 'tags))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self measurement) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; repeated .opencensus.proto.stats.v1.Tag tags = 1[json_name = "tags"];
  (cl:let* ((v (cl:slot-value self 'tags))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; string measure_name = 2[json_name = "measureName"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'measure-name) 'pb::%octets%))))
  ;; double double_value = 3[json_name = "doubleValue"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 25))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'double-value))))
  ;; int64 int_value = 4[json_name = "intValue"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'int-value)))))
  ;; .google.protobuf.Timestamp time = 5[json_name = "time"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'time) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'time) buffer index limit)))
  index)

(cl:defmethod pb:merge-from-array ((self measurement) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; repeated .opencensus.proto.stats.v1.Tag tags = 1[json_name = "tags"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:make-instance 'opencensus.proto.stats.v1::tag)))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow"))
              (cl:vector-push-extend message (cl:slot-value self 'tags)))))
        ;; string measure_name = 2[json_name = "measureName"];
        ((18)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-octets-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'measure-name) (pb:string-field value))
            (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; double double_value = 3[json_name = "doubleValue"];
        ((25)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'double-value) value)
            (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; int64 int_value = 4[json_name = "intValue"];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'int-value) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; .google.protobuf.Timestamp time = 5[json_name = "time"];
        ((42)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'time)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'google.protobuf::timestamp))
                (cl:setf (cl:slot-value self 'time) message)
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self measurement) (from measurement))
  (cl:let* ((v (cl:slot-value self 'tags))
            (vf (cl:slot-value from 'tags))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'measure-name) (cl:slot-value from 'measure-name))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'double-value) (cl:slot-value from 'double-value))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'int-value) (cl:slot-value from 'int-value))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'time)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'google.protobuf::timestamp))
        (cl:setf (cl:slot-value self 'time) message)
        (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'time))))
)


