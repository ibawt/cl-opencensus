
;;;;    opencensus/proto/trace/v1/trace_config.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:opencensus.proto.trace.v1)
    (make-package '#:opencensus.proto.trace.v1 :use nil)))
(in-package #:opencensus.proto.trace.v1)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:deftype constant-sampler-constant-decision () '(cl:member 0 1 2))
(cl:export 'constant-sampler-constant-decision)

(cl:defconstant +constant-sampler-constant-decision-always-off+ 0)
(cl:export '+constant-sampler-constant-decision-always-off+)
(cl:defconstant +constant-sampler-constant-decision-always-on+ 1)
(cl:export '+constant-sampler-constant-decision-always-on+)
(cl:defconstant +constant-sampler-constant-decision-always-parent+ 2)
(cl:export '+constant-sampler-constant-decision-always-parent+)

(cl:defconstant +minimum-constant-sampler-constant-decision+ +constant-sampler-constant-decision-always-off+)
(cl:export '+minimum-constant-sampler-constant-decision+)
(cl:defconstant +maximum-constant-sampler-constant-decision+ +constant-sampler-constant-decision-always-parent+)
(cl:export '+maximum-constant-sampler-constant-decision+)

(cl:defclass trace-config (pb:protocol-buffer)
  (
  (probability-sampler
   :writer (cl:setf probability-sampler)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.trace.v1::probability-sampler))
  (constant-sampler
   :writer (cl:setf constant-sampler)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.trace.v1::constant-sampler))
  (rate-limiting-sampler
   :writer (cl:setf rate-limiting-sampler)
   :initform cl:nil
   :type (cl:or cl:null opencensus.proto.trace.v1::rate-limiting-sampler))
  (max-number-of-attributes
   :accessor max-number-of-attributes
   :initform 0
   :type (cl:signed-byte 64))
  (max-number-of-annotations
   :accessor max-number-of-annotations
   :initform 0
   :type (cl:signed-byte 64))
  (max-number-of-message-events
   :accessor max-number-of-message-events
   :initform 0
   :type (cl:signed-byte 64))
  (max-number-of-links
   :accessor max-number-of-links
   :initform 0
   :type (cl:signed-byte 64))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 7))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'trace-config)

(cl:export 'probability-sampler)

(cl:unless (cl:fboundp 'probability-sampler)
  (cl:defgeneric probability-sampler (proto)))
(cl:defmethod probability-sampler ((self trace-config))
  (cl:let ((result (cl:slot-value self 'probability-sampler)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.trace.v1::probability-sampler))
      (cl:setf (cl:slot-value self 'probability-sampler) result))
      (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf probability-sampler) :after (x (self trace-config))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-probability-sampler)
  (cl:defgeneric has-probability-sampler (proto)))
(cl:defmethod has-probability-sampler ((self trace-config))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-probability-sampler)

(cl:unless (cl:fboundp 'clear-probability-sampler)
  (cl:defgeneric clear-probability-sampler (proto)))
(cl:defmethod clear-probability-sampler ((self trace-config))
  (cl:setf (cl:slot-value self 'probability-sampler) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-probability-sampler)

(cl:export 'constant-sampler)

(cl:unless (cl:fboundp 'constant-sampler)
  (cl:defgeneric constant-sampler (proto)))
(cl:defmethod constant-sampler ((self trace-config))
  (cl:let ((result (cl:slot-value self 'constant-sampler)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.trace.v1::constant-sampler))
      (cl:setf (cl:slot-value self 'constant-sampler) result))
      (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf constant-sampler) :after (x (self trace-config))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-constant-sampler)
  (cl:defgeneric has-constant-sampler (proto)))
(cl:defmethod has-constant-sampler ((self trace-config))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:export 'has-constant-sampler)

(cl:unless (cl:fboundp 'clear-constant-sampler)
  (cl:defgeneric clear-constant-sampler (proto)))
(cl:defmethod clear-constant-sampler ((self trace-config))
  (cl:setf (cl:slot-value self 'constant-sampler) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-constant-sampler)

(cl:export 'rate-limiting-sampler)

(cl:unless (cl:fboundp 'rate-limiting-sampler)
  (cl:defgeneric rate-limiting-sampler (proto)))
(cl:defmethod rate-limiting-sampler ((self trace-config))
  (cl:let ((result (cl:slot-value self 'rate-limiting-sampler)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'opencensus.proto.trace.v1::rate-limiting-sampler))
      (cl:setf (cl:slot-value self 'rate-limiting-sampler) result))
      (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf rate-limiting-sampler) :after (x (self trace-config))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-rate-limiting-sampler)
  (cl:defgeneric has-rate-limiting-sampler (proto)))
(cl:defmethod has-rate-limiting-sampler ((self trace-config))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:export 'has-rate-limiting-sampler)

(cl:unless (cl:fboundp 'clear-rate-limiting-sampler)
  (cl:defgeneric clear-rate-limiting-sampler (proto)))
(cl:defmethod clear-rate-limiting-sampler ((self trace-config))
  (cl:setf (cl:slot-value self 'rate-limiting-sampler) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-rate-limiting-sampler)

(cl:export 'max-number-of-attributes)


(cl:defmethod (cl:setf max-number-of-attributes) :after (x (self trace-config))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-max-number-of-attributes)
  (cl:defgeneric has-max-number-of-attributes (proto)))
(cl:defmethod has-max-number-of-attributes ((self trace-config))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:export 'has-max-number-of-attributes)

(cl:unless (cl:fboundp 'clear-max-number-of-attributes)
  (cl:defgeneric clear-max-number-of-attributes (proto)))
(cl:defmethod clear-max-number-of-attributes ((self trace-config))
  (cl:setf (cl:slot-value self 'max-number-of-attributes) 0)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-max-number-of-attributes)

(cl:export 'max-number-of-annotations)


(cl:defmethod (cl:setf max-number-of-annotations) :after (x (self trace-config))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-max-number-of-annotations)
  (cl:defgeneric has-max-number-of-annotations (proto)))
(cl:defmethod has-max-number-of-annotations ((self trace-config))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:export 'has-max-number-of-annotations)

(cl:unless (cl:fboundp 'clear-max-number-of-annotations)
  (cl:defgeneric clear-max-number-of-annotations (proto)))
(cl:defmethod clear-max-number-of-annotations ((self trace-config))
  (cl:setf (cl:slot-value self 'max-number-of-annotations) 0)
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-max-number-of-annotations)

(cl:export 'max-number-of-message-events)


(cl:defmethod (cl:setf max-number-of-message-events) :after (x (self trace-config))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-max-number-of-message-events)
  (cl:defgeneric has-max-number-of-message-events (proto)))
(cl:defmethod has-max-number-of-message-events ((self trace-config))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:export 'has-max-number-of-message-events)

(cl:unless (cl:fboundp 'clear-max-number-of-message-events)
  (cl:defgeneric clear-max-number-of-message-events (proto)))
(cl:defmethod clear-max-number-of-message-events ((self trace-config))
  (cl:setf (cl:slot-value self 'max-number-of-message-events) 0)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-max-number-of-message-events)

(cl:export 'max-number-of-links)


(cl:defmethod (cl:setf max-number-of-links) :after (x (self trace-config))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-max-number-of-links)
  (cl:defgeneric has-max-number-of-links (proto)))
(cl:defmethod has-max-number-of-links ((self trace-config))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:export 'has-max-number-of-links)

(cl:unless (cl:fboundp 'clear-max-number-of-links)
  (cl:defgeneric clear-max-number-of-links (proto)))
(cl:defmethod clear-max-number-of-links ((self trace-config))
  (cl:setf (cl:slot-value self 'max-number-of-links) 0)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-max-number-of-links)


(cl:defmethod cl:print-object ((self trace-config) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_probability-sampler: ~s" (probability-sampler self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_constant-sampler: ~s" (constant-sampler self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_rate-limiting-sampler: ~s" (rate-limiting-sampler self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_max-number-of-attributes: ~s" (max-number-of-attributes self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_max-number-of-annotations: ~s" (max-number-of-annotations self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_max-number-of-message-events: ~s" (max-number-of-message-events self)))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_max-number-of-links: ~s" (max-number-of-links self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self trace-config))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'probability-sampler) cl:nil))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'constant-sampler) cl:nil))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'rate-limiting-sampler) cl:nil))
  (cl:setf (cl:slot-value self 'max-number-of-attributes) 0)
  (cl:setf (cl:slot-value self 'max-number-of-annotations) 0)
  (cl:setf (cl:slot-value self 'max-number-of-message-events) 0)
  (cl:setf (cl:slot-value self 'max-number-of-links) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self trace-config))
  cl:t)

(cl:defmethod pb:octet-size ((self trace-config))
  (cl:let ((size 0))
    ;; .opencensus.proto.trace.v1.ProbabilitySampler probability_sampler = 1[json_name = "probabilitySampler"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'probability-sampler))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.trace.v1.ConstantSampler constant_sampler = 2[json_name = "constantSampler"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'constant-sampler))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; .opencensus.proto.trace.v1.RateLimitingSampler rate_limiting_sampler = 3[json_name = "rateLimitingSampler"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'rate-limiting-sampler))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; int64 max_number_of_attributes = 4[json_name = "maxNumberOfAttributes"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'max-number-of-attributes))))))
    ;; int64 max_number_of_annotations = 5[json_name = "maxNumberOfAnnotations"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'max-number-of-annotations))))))
    ;; int64 max_number_of_message_events = 6[json_name = "maxNumberOfMessageEvents"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'max-number-of-message-events))))))
    ;; int64 max_number_of_links = 7[json_name = "maxNumberOfLinks"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'max-number-of-links))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self trace-config) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .opencensus.proto.trace.v1.ProbabilitySampler probability_sampler = 1[json_name = "probabilitySampler"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'probability-sampler) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'probability-sampler) buffer index limit)))
  ;; .opencensus.proto.trace.v1.ConstantSampler constant_sampler = 2[json_name = "constantSampler"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'constant-sampler) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'constant-sampler) buffer index limit)))
  ;; .opencensus.proto.trace.v1.RateLimitingSampler rate_limiting_sampler = 3[json_name = "rateLimitingSampler"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'rate-limiting-sampler) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'rate-limiting-sampler) buffer index limit)))
  ;; int64 max_number_of_attributes = 4[json_name = "maxNumberOfAttributes"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 32))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'max-number-of-attributes)))))
  ;; int64 max_number_of_annotations = 5[json_name = "maxNumberOfAnnotations"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 40))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'max-number-of-annotations)))))
  ;; int64 max_number_of_message_events = 6[json_name = "maxNumberOfMessageEvents"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'max-number-of-message-events)))))
  ;; int64 max_number_of_links = 7[json_name = "maxNumberOfLinks"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 56))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'max-number-of-links)))))
  index)

(cl:defmethod pb:merge-from-array ((self trace-config) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .opencensus.proto.trace.v1.ProbabilitySampler probability_sampler = 1[json_name = "probabilitySampler"];
        ((10)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'probability-sampler)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.trace.v1::probability-sampler))
                (cl:setf (cl:slot-value self 'probability-sampler) message)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .opencensus.proto.trace.v1.ConstantSampler constant_sampler = 2[json_name = "constantSampler"];
        ((18)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'constant-sampler)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.trace.v1::constant-sampler))
                (cl:setf (cl:slot-value self 'constant-sampler) message)
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; .opencensus.proto.trace.v1.RateLimitingSampler rate_limiting_sampler = 3[json_name = "rateLimitingSampler"];
        ((26)
          (cl:multiple-value-bind (length new-index)
              (varint:parse-uint31-carefully buffer index limit)
            (cl:when (cl:> (cl:+ new-index length) limit)
              (cl:error "buffer overflow"))
            (cl:let ((message (cl:slot-value self 'rate-limiting-sampler)))
              (cl:when (cl:null message)
                (cl:setf message (cl:make-instance 'opencensus.proto.trace.v1::rate-limiting-sampler))
                (cl:setf (cl:slot-value self 'rate-limiting-sampler) message)
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
              (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
              (cl:when (cl:not (cl:= index (cl:+ new-index length)))
                (cl:error "buffer overflow")))))
        ;; int64 max_number_of_attributes = 4[json_name = "maxNumberOfAttributes"];
        ((32)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'max-number-of-attributes) value)
            (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; int64 max_number_of_annotations = 5[json_name = "maxNumberOfAnnotations"];
        ((40)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'max-number-of-annotations) value)
            (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; int64 max_number_of_message_events = 6[json_name = "maxNumberOfMessageEvents"];
        ((48)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'max-number-of-message-events) value)
            (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        ;; int64 max_number_of_links = 7[json_name = "maxNumberOfLinks"];
        ((56)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'max-number-of-links) value)
            (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self trace-config) (from trace-config))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'probability-sampler)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.trace.v1::probability-sampler))
        (cl:setf (cl:slot-value self 'probability-sampler) message)
        (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'probability-sampler))))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'constant-sampler)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.trace.v1::constant-sampler))
        (cl:setf (cl:slot-value self 'constant-sampler) message)
        (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'constant-sampler))))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'rate-limiting-sampler)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'opencensus.proto.trace.v1::rate-limiting-sampler))
        (cl:setf (cl:slot-value self 'rate-limiting-sampler) message)
        (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'rate-limiting-sampler))))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'max-number-of-attributes) (cl:slot-value from 'max-number-of-attributes))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'max-number-of-annotations) (cl:slot-value from 'max-number-of-annotations))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'max-number-of-message-events) (cl:slot-value from 'max-number-of-message-events))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'max-number-of-links) (cl:slot-value from 'max-number-of-links))
    (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass probability-sampler (pb:protocol-buffer)
  (
  (sampling-probability
   :accessor sampling-probability
   :initform 0d0
   :type cl:double-float)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'probability-sampler)

(cl:export 'sampling-probability)


(cl:defmethod (cl:setf sampling-probability) :after (x (self probability-sampler))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-sampling-probability)
  (cl:defgeneric has-sampling-probability (proto)))
(cl:defmethod has-sampling-probability ((self probability-sampler))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-sampling-probability)

(cl:unless (cl:fboundp 'clear-sampling-probability)
  (cl:defgeneric clear-sampling-probability (proto)))
(cl:defmethod clear-sampling-probability ((self probability-sampler))
  (cl:setf (cl:slot-value self 'sampling-probability) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-sampling-probability)


(cl:defmethod cl:print-object ((self probability-sampler) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_sampling-probability: ~s" (sampling-probability self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self probability-sampler))
  (cl:setf (cl:slot-value self 'sampling-probability) 0d0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self probability-sampler))
  cl:t)

(cl:defmethod pb:octet-size ((self probability-sampler))
  (cl:let ((size 0))
    ;; double samplingProbability = 1[json_name = "samplingProbability"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self probability-sampler) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; double samplingProbability = 1[json_name = "samplingProbability"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 9))
    (cl:setf index (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'sampling-probability))))
  index)

(cl:defmethod pb:merge-from-array ((self probability-sampler) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; double samplingProbability = 1[json_name = "samplingProbability"];
        ((9)
          (cl:multiple-value-bind (value new-index)
              (wire-format:read-double-float-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'sampling-probability) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self probability-sampler) (from probability-sampler))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'sampling-probability) (cl:slot-value from 'sampling-probability))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass constant-sampler (pb:protocol-buffer)
  (
  (decision
   :accessor decision
   :initform opencensus.proto.trace.v1::+constant-sampler-constant-decision-always-off+
   :type opencensus.proto.trace.v1::constant-sampler-constant-decision)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'constant-sampler)

(cl:export 'decision)


(cl:defmethod (cl:setf decision) :after (x (self constant-sampler))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-decision)
  (cl:defgeneric has-decision (proto)))
(cl:defmethod has-decision ((self constant-sampler))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-decision)

(cl:unless (cl:fboundp 'clear-decision)
  (cl:defgeneric clear-decision (proto)))
(cl:defmethod clear-decision ((self constant-sampler))
  (cl:setf (cl:slot-value self 'decision) opencensus.proto.trace.v1::+constant-sampler-constant-decision-always-off+)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-decision)


(cl:defmethod cl:print-object ((self constant-sampler) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_decision: ~s" (decision self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self constant-sampler))
  (cl:setf (cl:slot-value self 'decision) opencensus.proto.trace.v1::+constant-sampler-constant-decision-always-off+)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self constant-sampler))
  cl:t)

(cl:defmethod pb:octet-size ((self constant-sampler))
  (cl:let ((size 0))
    ;; .opencensus.proto.trace.v1.ConstantSampler.ConstantDecision decision = 1[json_name = "decision"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'decision)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self constant-sampler) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; .opencensus.proto.trace.v1.ConstantSampler.ConstantDecision decision = 1[json_name = "decision"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
     (varint:encode-uint64-carefully buffer index limit
      (cl:ldb (cl:byte 64 0) (cl:slot-value self 'decision)))))
  index)

(cl:defmethod pb:merge-from-array ((self constant-sampler) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; .opencensus.proto.trace.v1.ConstantSampler.ConstantDecision decision = 1[json_name = "decision"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int32-carefully buffer index limit)
            ;; XXXXX: when valid, set field, else add to unknown fields
            (cl:setf (cl:slot-value self 'decision) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self constant-sampler) (from constant-sampler))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'decision) (cl:slot-value from 'decision))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
)


(cl:defclass rate-limiting-sampler (pb:protocol-buffer)
  (
  (qps
   :accessor qps
   :initform 0
   :type (cl:signed-byte 64))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:export 'rate-limiting-sampler)

(cl:export 'qps)


(cl:defmethod (cl:setf qps) :after (x (self rate-limiting-sampler))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-qps)
  (cl:defgeneric has-qps (proto)))
(cl:defmethod has-qps ((self rate-limiting-sampler))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:export 'has-qps)

(cl:unless (cl:fboundp 'clear-qps)
  (cl:defgeneric clear-qps (proto)))
(cl:defmethod clear-qps ((self rate-limiting-sampler))
  (cl:setf (cl:slot-value self 'qps) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:export 'clear-qps)


(cl:defmethod cl:print-object ((self rate-limiting-sampler) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_qps: ~s" (qps self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self rate-limiting-sampler))
  (cl:setf (cl:slot-value self 'qps) 0)
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self rate-limiting-sampler))
  cl:t)

(cl:defmethod pb:octet-size ((self rate-limiting-sampler))
  (cl:let ((size 0))
    ;; int64 qps = 1[json_name = "qps"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'qps))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self rate-limiting-sampler) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; int64 qps = 1[json_name = "qps"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'qps)))))
  index)

(cl:defmethod pb:merge-from-array ((self rate-limiting-sampler) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (tag new-index)
        (varint:parse-uint32-carefully buffer index limit)
      (cl:setf index new-index)
      (cl:case tag
        ;; int64 qps = 1[json_name = "qps"];
        ((8)
          (cl:multiple-value-bind (value new-index)
              (varint:parse-int64-carefully buffer index limit)
            (cl:setf (cl:slot-value self 'qps) value)
            (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
            (cl:setf index new-index)))
        (cl:t
          (cl:when (cl:= (cl:logand tag 7) 4)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field buffer index limit tag)))))))

(cl:defmethod pb:merge-from-message ((self rate-limiting-sampler) (from rate-limiting-sampler))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'qps) (cl:slot-value from 'qps))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
)


